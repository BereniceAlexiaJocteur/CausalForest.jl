var documenterSearchIndex = {"docs":
[{"location":"index.html","page":"Introduction","title":"Introduction","text":"Modules = [CausalForest]","category":"page"},{"location":"index.html#CausalForest.apply_forest-Union{Tuple{S}, Tuple{CausalForest.EnsembleCausal{S}, AbstractMatrix{S}}} where S","page":"Introduction","title":"CausalForest.apply_forest","text":"Get the causal effect for each row in x given a causal forest\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.apply_forest_1-Union{Tuple{S}, Tuple{CausalForest.EnsembleCausal{S}, AbstractMatrix{S}}} where S","page":"Introduction","title":"CausalForest.apply_forest_1","text":"Get the causal effect for each row in x given a causal forest\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.apply_forest_2-Union{Tuple{S}, Tuple{CausalForest.EnsembleCausal{S}, AbstractMatrix{S}}} where S","page":"Introduction","title":"CausalForest.apply_forest_2","text":"Get the causal effect for each row in x given a causal forest\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.apply_forest_2bis-Union{Tuple{S}, Tuple{CausalForest.EnsembleCausal{S}, AbstractMatrix{S}}} where S","page":"Introduction","title":"CausalForest.apply_forest_2bis","text":"Get the causal effect for each row in x given a causal forest\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.apply_forest_3-Union{Tuple{S}, Tuple{CausalForest.EnsembleCausal{S}, AbstractMatrix{S}}} where S","page":"Introduction","title":"CausalForest.apply_forest_3","text":"Get the causal effect for each row in x given a causal forest\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.apply_forest_3_ols-Union{Tuple{S}, Tuple{CausalForest.EnsembleCausal{S}, AbstractMatrix{S}}} where S","page":"Introduction","title":"CausalForest.apply_forest_3_ols","text":"Get the causal effect for each row in x given a causal forest\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.apply_forest_3_xgboost-Union{Tuple{S}, Tuple{CausalForest.EnsembleCausal{S}, AbstractMatrix{S}}} where S","page":"Introduction","title":"CausalForest.apply_forest_3_xgboost","text":"Get the causal effect for each row in x given a causal forest\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.apply_forest_oob-Union{Tuple{EnsembleOOB{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Introduction","title":"CausalForest.apply_forest_oob","text":"Prediction on out of bag sample for a random forest\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.build_forest-Union{Tuple{T}, Tuple{S}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any, Any}} where {S, T<:Float64}","page":"Introduction","title":"CausalForest.build_forest","text":"Build a causal forest.\n\nif centering=True Y and W are centered else they stay unchanged\nif bootstrap=True we sample for each tree via bootstrap else we use subsampling\nif honest=True we use 2 samples one too build splits and the other one to fill leaves   otherwise we use the whole sample for the two steps\nif const_mtry=True we use a constant mtry otherwise we use a random mtry following   min(max(Poisson(m_pois),1),number_of_features)\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.build_forest_1-Union{Tuple{T}, Tuple{S}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any, Any}} where {S, T<:Float64}","page":"Introduction","title":"CausalForest.build_forest_1","text":"Build a causal forest.\n\nif centering=True Y and W are centered else they stay unchanged\nif bootstrap=True we sample for each tree via bootstrap else we use subsampling\nif honest=True we use 2 samples one too build splits and the other one to fill leaves   otherwise we use the whole sample for the two steps\nif const_mtry=True we use a constant mtry otherwise we use a random mtry following   min(max(Poisson(m_pois),1),number_of_features)\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.build_forest_1_opti-Union{Tuple{T}, Tuple{S}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any, Any}} where {S, T<:Float64}","page":"Introduction","title":"CausalForest.build_forest_1_opti","text":"Build a causal forest.\n\nif centering=True Y and W are centered else they stay unchanged\nif bootstrap=True we sample for each tree via bootstrap else we use subsampling\nif honest=True we use 2 samples one too build splits and the other one to fill leaves   otherwise we use the whole sample for the two steps\nif const_mtry=True we use a constant mtry otherwise we use a random mtry following   min(max(Poisson(m_pois),1),number_of_features)\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.build_forest_1_opti_corr-Union{Tuple{T}, Tuple{S}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any, Any}} where {S, T<:Float64}","page":"Introduction","title":"CausalForest.build_forest_1_opti_corr","text":"Build a causal forest.\n\nif centering=True Y and W are centered else they stay unchanged\nif bootstrap=True we sample for each tree via bootstrap else we use subsampling\nif honest=True we use 2 samples one too build splits and the other one to fill leaves   otherwise we use the whole sample for the two steps\nif const_mtry=True we use a constant mtry otherwise we use a random mtry following   min(max(Poisson(m_pois),1),number_of_features)\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.build_forest_2-Union{Tuple{T}, Tuple{S}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any, Any}} where {S, T<:Float64}","page":"Introduction","title":"CausalForest.build_forest_2","text":"Build a causal forest.\n\nif centering=True Y and W are centered else they stay unchanged\nif bootstrap=True we sample for each tree via bootstrap else we use subsampling\nif honest=True we use 2 samples one too build splits and the other one to fill leaves   otherwise we use the whole sample for the two steps\nif const_mtry=True we use a constant mtry otherwise we use a random mtry following   min(max(Poisson(m_pois),1),number_of_features)\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.build_forest_3_opti-Union{Tuple{T}, Tuple{S}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any, Any}} where {S, T<:Float64}","page":"Introduction","title":"CausalForest.build_forest_3_opti","text":"Build a causal forest.\n\nif centering=True Y and W are centered else they stay unchanged\nif bootstrap=True we sample for each tree via bootstrap else we use subsampling\nif honest=True we use 2 samples one too build splits and the other one to fill leaves   otherwise we use the whole sample for the two steps\nif const_mtry=True we use a constant mtry otherwise we use a random mtry following   min(max(Poisson(m_pois),1),number_of_features)\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.build_forest_3_opti_ols-Union{Tuple{T}, Tuple{S}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any, Any}} where {S, T<:Float64}","page":"Introduction","title":"CausalForest.build_forest_3_opti_ols","text":"Build a causal forest.\n\nif centering=True Y and W are centered else they stay unchanged\nif bootstrap=True we sample for each tree via bootstrap else we use subsampling\nif honest=True we use 2 samples one too build splits and the other one to fill leaves   otherwise we use the whole sample for the two steps\nif const_mtry=True we use a constant mtry otherwise we use a random mtry following   min(max(Poisson(m_pois),1),number_of_features)\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.build_forest_3_opti_xgboost-Union{Tuple{T}, Tuple{S}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any, Any}} where {S, T<:Float64}","page":"Introduction","title":"CausalForest.build_forest_3_opti_xgboost","text":"Build a causal forest.\n\nif centering=True Y and W are centered else they stay unchanged\nif bootstrap=True we sample for each tree via bootstrap else we use subsampling\nif honest=True we use 2 samples one too build splits and the other one to fill leaves   otherwise we use the whole sample for the two steps\nif const_mtry=True we use a constant mtry otherwise we use a random mtry following   min(max(Poisson(m_pois),1),number_of_features)\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.build_forest_oob-Union{Tuple{T}, Tuple{S}, Tuple{AbstractVector{T}, AbstractMatrix{S}}, Tuple{AbstractVector{T}, AbstractMatrix{S}, Any}, Tuple{AbstractVector{T}, AbstractMatrix{S}, Any, Any}, Tuple{AbstractVector{T}, AbstractMatrix{S}, Any, Any, Any}, Tuple{AbstractVector{T}, AbstractMatrix{S}, Any, Any, Any, Any}, Tuple{AbstractVector{T}, AbstractMatrix{S}, Any, Any, Any, Any, Any}, Tuple{AbstractVector{T}, AbstractMatrix{S}, Any, Any, Any, Any, Any, Any}, Tuple{AbstractVector{T}, AbstractMatrix{S}, Any, Any, Any, Any, Any, Any, Any}} where {S, T}","page":"Introduction","title":"CausalForest.build_forest_oob","text":"Build a random forest which keep track of the oob sample\n\n\n\n\n\n","category":"method"},{"location":"index.html#CausalForest.build_forest_opti-Union{Tuple{T}, Tuple{S}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any}, Tuple{Bool, Bool, Bool, AbstractVector{T}, AbstractVector{Int64}, AbstractMatrix{S}, Bool, Any, Any, Any, Any, Any, Any, Any, Any}} where {S, T<:Float64}","page":"Introduction","title":"CausalForest.build_forest_opti","text":"Build a causal forest.\n\nif centering=True Y and W are centered else they stay unchanged\nif bootstrap=True we sample for each tree via bootstrap else we use subsampling\nif honest=True we use 2 samples one too build splits and the other one to fill leaves   otherwise we use the whole sample for the two steps\nif const_mtry=True we use a constant mtry otherwise we use a random mtry following   min(max(Poisson(m_pois),1),number_of_features)\n\n\n\n\n\n","category":"method"}]
}
